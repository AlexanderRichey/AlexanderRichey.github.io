<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Alex Richey | Blog | Error Handling in Go REST APIs</title><meta name=description content="A pattern for distinguishing and handling client and internal errors in Go that leverages the power of Go's interfaces."><link rel=alternate type=application/rss+xml href=/rss.xml><link rel=stylesheet href=/styles/styles.ec746e09.css><script async src=https://plausible.io/js/analytics.js></script><link async defer rel=stylesheet href=https://cdn.jsdelivr.net/npm/@openfonts/public-sans_latin@0.0.2/index.min.css><link async defer rel=stylesheet href=https://cdn.jsdelivr.net/npm/@openfonts/literata_latin@1.44.3/index.min.css><script async src=https://cdn.jsdelivr.net/npm/@hotwired/turbo@7.0.0-rc.3/dist/turbo.es2017-umd.js></script><script src=/scripts/img-grow.3f34b1c6.js></script></head><body><header class=top-header><div class=top-header-title><h1><a href=/>Alex Richey</a></h1><small>Software Engineer @ Amazon</small></div><nav class=top-header-nav><a class=top-header-nav-item href=/>Posts</a>
<a class=top-header-nav-item href=/about.html>About</a></nav></header><main class=container><article><div class=article-header><h1>Error Handling in Go REST APIs</h1><time class=article-date datetime="2021-09-09 00:00:00 +0000 UTC">9 September 2021</time></div><div><aside class=message>This post is reblogged from <a href=https://linksort.com/blog/error-handling-in-go-rest-apis/>Linksort's blog</a> where it originally appeared.</aside><p>In writing a REST API, we have to deal with at least two types of errors.</p><ul><li><strong>Client errors:</strong> These errors are the fault of the user, e.g., providing an invalid email address, or a password that's too short. These errors are in the HTTP status range 400-499.</li><li><strong>Internal errors:</strong> These errors are not that fault of the user. As the author of the codebase in question, these errors <em>are my fault</em> or the fault of one or more of my dependencies. They often mean that there's a bug in the code that I wrote, or other code that I'm using, or that a dependent service is down. These errors are in the HTTP status range 500-599.</li></ul><p>The problem is that Go's standard library's <code>errors</code> package does not make it easy to distinguish these cases. Here's an example. Let's say I have a simple HTTP handler that validates the incoming request and returns an error if the validation fails and does some work if the validation succeeds.</p><pre style=background-color:#fff><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>MyHandler</span>(w http.ResponseWriter, r <span style=color:#000;font-weight:700>*</span>http.Request) {
	err <span style=color:#000;font-weight:700>:=</span> <span style=color:#900;font-weight:700>validateRequest</span>(r)
	<span style=color:#000;font-weight:700>if</span> err <span style=color:#000;font-weight:700>!=</span> <span style=color:#000;font-weight:700>nil</span> {
		w.<span style=color:#900;font-weight:700>WriteHeader</span>(http.StatusBadRequest) 
		w.<span style=color:#900;font-weight:700>Write</span>(err.<span style=color:#900;font-weight:700>Error</span>())
		<span style=color:#000;font-weight:700>return</span>
  }
  
  <span style=color:#998;font-style:italic>// Do work.
</span><span style=color:#998;font-style:italic></span>}
</pre><p>The problem with the code above is that it doesn't account for the case where the <code>validateRequest()</code> function fails because of an internal error. This code would hide what could be a programming issue or an issue with a dependency and would falsely classify it as a client error with status 400. That's bad. It prevents me, as the service owner, from knowing that something's wrong; and it also prevents the end-user from accurately figuring out what actions they might need to take.</p><p>Moreover, depending on the way <code>validateRequest()</code> is written, we might end up exposing security related information to the user by simply writing <code>err.Error()</code> to the HTTP response body. What if <code>validateRequest()</code> returns an error that says "downstream auth service is down"? That would not be an appropriate message to send to the end user.</p><h2>Package <code>errors</code></h2><p>I couldn't figure out how to handle this kind of case elegantly until a collegue at work recommended I read Rob Pike and Andrew Gerrand's article <a href=https://commandcenter.blogspot.com/2017/12/error-handling-in-upspin.html>"Error handing in Upspin</a>." The key insight of the article—which maybe should have been obvious to me—is that I can define my own error type. The only thing required for something to be an error in Go is that it satisfy the error interface, which is simply:</p><pre style=background-color:#fff><span style=color:#000;font-weight:700>type</span> Error <span style=color:#000;font-weight:700>interface</span> {
	<span style=color:#900;font-weight:700>Error</span>() <span style=color:#458;font-weight:700>string</span>
}
</pre><p>When something satisfies this interface, that doesn't mean that it can't satisfy other interfaces too. In other words, the object that implements the error interface can include more functionality and information than just the <code>Error()</code> method. Here's why this is important: I can add additional information to a custom <code>Error</code> type that will allow me to distinguish between client and internal errors and which satisfies the standard library's <code>Error</code> interface.</p><p>Following Upspin's example, with a few modifications, I defined my own error type in a new errors package like so:</p><pre style=background-color:#fff><span style=color:#998;font-style:italic>// Op describes an operation, usually as the package and method,
</span><span style=color:#998;font-style:italic>// such as db.GetUser.
</span><span style=color:#998;font-style:italic></span><span style=color:#000;font-weight:700>type</span> Op <span style=color:#458;font-weight:700>string</span>

<span style=color:#998;font-style:italic>// Error implements the error interface.
</span><span style=color:#998;font-style:italic></span><span style=color:#000;font-weight:700>type</span> Error <span style=color:#000;font-weight:700>struct</span> {
        err      <span style=color:#458;font-weight:700>error</span> <span style=color:#998;font-style:italic>// The underlying error, if there is one
</span><span style=color:#998;font-style:italic></span>        code     <span style=color:#458;font-weight:700>int</span>   <span style=color:#998;font-style:italic>// The HTTP status code
</span><span style=color:#998;font-style:italic></span>        op       Op    <span style=color:#998;font-style:italic>// The operation where the error occured
</span><span style=color:#998;font-style:italic></span>        messages <span style=color:#000;font-weight:700>map</span>[<span style=color:#458;font-weight:700>string</span>]<span style=color:#458;font-weight:700>string</span> <span style=color:#998;font-style:italic>// A customer-facing message
</span><span style=color:#998;font-style:italic></span>}
</pre><p>The fields of <code>Error</code> are used to distinguish client from internal errors, to provide customer-facing error messages, and to provide useful traces.</p><p>I also wrote a function called <code>E()</code>, whose name I also took from Upspin, to make it easy to create these errors. Here's how it looks when it's used. You can find the implementation <a href=https://github.com/linksort/linksort/blob/main/errors/errors.go>on GitHub</a>.</p><pre style=background-color:#fff><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>validateRequest</span>(r <span style=color:#000;font-weight:700>*</span>http.Request) <span style=color:#458;font-weight:700>error</span> {
	op <span style=color:#000;font-weight:700>:=</span> errors.<span style=color:#900;font-weight:700>Op</span>(<span style=color:#d14>&#34;validateRequest&#34;</span>)
	
	c, err <span style=color:#000;font-weight:700>:=</span> r.<span style=color:#900;font-weight:700>Cookie</span>(<span style=color:#d14>&#34;session-id&#34;</span>)
	<span style=color:#000;font-weight:700>if</span> err <span style=color:#000;font-weight:700>!=</span> <span style=color:#000;font-weight:700>nil</span> {
		<span style=color:#000;font-weight:700>if</span> errors.<span style=color:#900;font-weight:700>Is</span>(err, http.ErrorNoCookie) {
			<span style=color:#000;font-weight:700>return</span> errors.<span style=color:#900;font-weight:700>E</span>(op, err, http.StatusUnauthorized, <span style=color:#000;font-weight:700>map</span>[<span style=color:#458;font-weight:700>string</span>]<span style=color:#458;font-weight:700>string</span>{
				<span style=color:#d14>&#34;message&#34;</span>: <span style=color:#d14>&#34;Required session cookie was not found.&#34;</span>,
			})
		}
		
		<span style=color:#000;font-weight:700>return</span> errors.<span style=color:#900;font-weight:700>E</span>(op, err, http.StatusInternalServerError, <span style=color:#000;font-weight:700>map</span>[<span style=color:#458;font-weight:700>string</span>]<span style=color:#458;font-weight:700>string</span>{
			<span style=color:#d14>&#34;message&#34;</span>: <span style=color:#d14>&#34;An internal error occured. Please try again.&#34;</span>,
		})
	}
	
	<span style=color:#000;font-weight:700>return</span> <span style=color:#000;font-weight:700>nil</span>
}
</pre><p>Note that we've now distinguished between client and internal errors and provided a way to surface customer-facing error messages. The client error in this example is when a <code>session-id</code> cookie is missing from the incoming request. The internal error is when, for whatever reason, <code>r.Cookie()</code> returns an unexpected error. (In the <a href="https://cs.opensource.google/go/go/+/refs/tags/go1.17:src/net/http/request.go;l=421-426">implementation of <code>r.Cookie()</code></a>, this isn't actually possible, but I think this example gets the point across if you pretend that <code>r.Cookie()</code> could return such an unexpected error. It may also be worth mentioning that this is a toy example whose only purpose is to demonstrate <code>errors.E()</code>—there may be better patterns for validating cookies.)</p><p>Note that I also populated my project's <code>errors</code> package with other functions as well, such as <code>Is()</code>, <code>As()</code>, and <code>Unwrap()</code>, so that it can completely replace the standard library's <code>errors</code> package within the scope of my project.</p><h2>Package <code>payload</code></h2><p>Now that I have an <code>Error</code> type that's rich enough for me to distinguish among different kinds of errors, I need a way of returning them to end-users nicely and of printing their contents to my application's logs for debugging purposes. That's where package <code>payload</code> comes in.</p><p>Package <code>payload</code> provides utilities for dealing with HTTP requests and responses. I call it "payload" because it's primarily concerned with reading and writing request and response payloads. Here's how I use it to handle errors.</p><pre style=background-color:#fff><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>MyHandler</span>(w http.ResponseWriter, r <span style=color:#000;font-weight:700>*</span>http.Request) {
	err = <span style=color:#900;font-weight:700>validateRequest</span>(req)
	<span style=color:#000;font-weight:700>if</span> err <span style=color:#000;font-weight:700>!=</span> <span style=color:#000;font-weight:700>nil</span> {
		payload.<span style=color:#900;font-weight:700>WriteError</span>(w, r, err)
		<span style=color:#000;font-weight:700>return</span>
	}
	
	<span style=color:#998;font-style:italic>// Do work.
</span><span style=color:#998;font-style:italic></span>}
</pre><p>The intended behavior is that, no matter what error is given, <code>payload.WriteError(w, r, err)</code> will write the correct information to the response.</p><p>Here's how it works. In package <code>payload</code>, I defined an interface called <code>ClientReporter</code> that my custom <code>Error</code> type implements. (I left the implementation of this interface out of the definition above, but it should be straightforward. If it isn't, take a look at the source <a href=https://github.com/linksort/linksort/blob/a1f069924f2ca535218fee66deca7776fd9d4add/errors/errors.go#L72-L114>on GitHub</a>.)</p><pre style=background-color:#fff><span style=color:#998;font-style:italic>// ClientReporter provides information about an error such that client and
</span><span style=color:#998;font-style:italic>// server errors can be distinguished and handled appropriately.
</span><span style=color:#998;font-style:italic></span><span style=color:#000;font-weight:700>type</span> ClientReporter <span style=color:#000;font-weight:700>interface</span> {
        <span style=color:#458;font-weight:700>error</span>
        <span style=color:#900;font-weight:700>Message</span>() <span style=color:#000;font-weight:700>map</span>[<span style=color:#458;font-weight:700>string</span>]<span style=color:#458;font-weight:700>string</span>
        <span style=color:#900;font-weight:700>StatusCode</span>() <span style=color:#458;font-weight:700>int</span>
}
</pre><p>In <code>payload.WriteError(w, r, err)</code>, I check whether the given <code>err</code> implements <code>ClientReporter</code>. If it does, then I use that information to write the response to the user. If it doesn't then, I write a 500-level error to the response because that clearly means I didn't handle something right in my programming.</p><pre style=background-color:#fff><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>WriteError</span>(w http.ResponseWriter, r <span style=color:#000;font-weight:700>*</span>http.Request, e <span style=color:#458;font-weight:700>error</span>) {
	<span style=color:#000;font-weight:700>if</span> cr, ok <span style=color:#000;font-weight:700>:=</span> e.(ClientReporter); ok {
		status <span style=color:#000;font-weight:700>:=</span> cr.<span style=color:#900;font-weight:700>Status</span>()
		<span style=color:#000;font-weight:700>if</span> status <span style=color:#000;font-weight:700>&gt;=</span> http.StatusInternalServerError {
			<span style=color:#900;font-weight:700>handleInternalServerError</span>(w, r, e)
			<span style=color:#000;font-weight:700>return</span>
		}

		<span style=color:#998;font-style:italic>// Write is another function provided by package payload that handles
</span><span style=color:#998;font-style:italic></span>		<span style=color:#998;font-style:italic>// writing JSON to http.ResponseWriter.
</span><span style=color:#998;font-style:italic></span>		<span style=color:#900;font-weight:700>Write</span>(w, r, cr.<span style=color:#900;font-weight:700>Message</span>(), status)
		
		<span style=color:#000;font-weight:700>return</span>
	}

	<span style=color:#900;font-weight:700>handleInternalServerError</span>(w, r, e)
}

<span style=color:#000;font-weight:700>var</span> encodedErrResp []<span style=color:#458;font-weight:700>byte</span> = json.<span style=color:#900;font-weight:700>RawMessage</span>(<span style=color:#d14>`{&#34;message&#34;:&#34;Something has gone wrong&#34;}`</span>)

<span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>handleInternalServerError</span>(w http.ResponseWriter, r <span style=color:#000;font-weight:700>*</span>http.Request, e <span style=color:#458;font-weight:700>error</span>) {
	log.<span style=color:#900;font-weight:700>Print</span>(e.<span style=color:#900;font-weight:700>Error</span>()) <span style=color:#998;font-style:italic>// Log errors for debugging
</span><span style=color:#998;font-style:italic></span>	w.<span style=color:#900;font-weight:700>Header</span>().<span style=color:#900;font-weight:700>Add</span>(<span style=color:#d14>&#34;Content-Type&#34;</span>, <span style=color:#d14>&#34;application/json&#34;</span>)
	w.<span style=color:#900;font-weight:700>WriteHeader</span>(http.StatusInternalServerError)
	
	<span style=color:#000;font-weight:700>if</span> _, err <span style=color:#000;font-weight:700>:=</span> w.<span style=color:#900;font-weight:700>Write</span>(encodedErrResp); err <span style=color:#000;font-weight:700>!=</span> <span style=color:#000;font-weight:700>nil</span> {
		<span style=color:#998;font-style:italic>// panic, etc.
</span><span style=color:#998;font-style:italic></span>	}
}
</pre><p>With the combination of my custom package <code>errors</code> and package <code>payload</code>, I have a streamlined way of handing errors throughout my application. I can distinguish between client and internal errors based on their HTTP statuses, which are assigned to the errors when they are created with <code>errors.E()</code>. I can also provide customer-facing error messages, that are sure not to accidentally expose any security relevant information, by means of the <code>map[string]string</code> that can also be provided to <code>errors.E()</code>. At the same time, I can log useful traces by printing underlying error messages to my application's logs, as I do in <code>handleInternalServerError()</code> above, which will make my life easier when I have to debug issues.</p></div><aside class=aside-post-container><div class="aside-post left"><a href=/articles/2022-03-04-why-i-could-be-wrong.html><p class=aside-post-arrow>&#8592; Newer</p><p class=aside-post-title>Why I Could Be Wrong</p></a></div><div class="aside-post right"><a href=/articles/2021-04-01-orenstien-refactoring.html><p class=aside-post-arrow>Older &#8594;</p><p class=aside-post-title>Notes on Ben Orenstein's "Refactoring from Good to Great"</p></a></div></aside></article></main><footer><span>© 2022. All rights reserved. <a rel=alternate type=application/rss+xml href=/rss.xml>RSS</a>. <a href=/>Posts.</a> <a href=/about.html>About.</a></span></footer></body></html>
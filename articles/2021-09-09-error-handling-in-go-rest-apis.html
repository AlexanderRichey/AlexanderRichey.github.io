<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Alex Richey | Error Handling in Go REST APIs</title><meta name=description content="A pattern for distinguishing and handling client and internal errors in Go that leverages the power of Go's interfaces."><link rel=alternate type=application/rss+xml href=/rss.xml><script async src=https://plausible.io/js/analytics.js></script><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Source+Sans+Pro:ital,wght@0,400;0,700;1,400;1,700&family=Source+Serif+Pro:ital,wght@0,400;0,600;0,700;1,400;1,700&display=swap" rel=stylesheet><link rel=stylesheet href=/styles/styles.73658edd.css><script defer src=https://cdn.jsdelivr.net/npm/@hotwired/turbo@7.1.0/dist/turbo.es2017-umd.js></script><script defer src=/scripts/img-grow.990f00ca.js></script><meta property="og:site_name" content="Alex Richey"><meta name=twitter:site content="@AlexanderRichey"><link rel=me href=https://twitter.com/AlexanderRichey><link rel=me href=https://github.com/AlexanderRichey><link rel=webmention href=https://webmention.io/alexrichey.com/webmention><link rel=pingback href=https://webmention.io/alexrichey.com/xmlrpc><meta property="og:title" content="Error Handling in Go REST APIs"><meta property="og:type" content="article"><meta property="og:description" content="A pattern for distinguishing and handling client and internal errors in Go that leverages the power of Go's interfaces."><meta name=twitter:title content="Error Handling in Go REST APIs"><meta name=twitter:description content="A pattern for distinguishing and handling client and internal errors in Go that leverages the power of Go's interfaces."></head><body><header class=top-header><div class=top-header-title><h1><a href=/>Alex Richey</a></h1><small>Software Engineer @ Amazon</small></div><nav class=top-header-nav><a class=top-header-nav-item href=/>Posts</a>
<a class=top-header-nav-item href=/about.html>About</a></nav></header><main class=container><article><div class=article-header><h1>Error Handling in Go REST APIs</h1><time class=article-date datetime="2021-09-09 00:00:00 +0000 UTC">9 September 2021</time></div><div><aside class=message>This post is reblogged from <a href=https://linksort.com/blog/error-handling-in-go-rest-apis/>Linksort's blog</a> where it originally appeared.</aside><p>In writing a REST API, we have to deal with at least two types of errors.</p><ul><li><strong>Client errors:</strong> These errors are the fault of the user, e.g., providing an invalid email address, or a password that's too short. These errors are in the HTTP status range 400-499.</li><li><strong>Internal errors:</strong> These errors are not that fault of the user. As the author of the codebase in question, these errors <em>are my fault</em> or the fault of one or more of my dependencies. They often mean that there's a bug in the code that I wrote, or other code that I'm using, or that a dependent service is down. These errors are in the HTTP status range 500-599.</li></ul><p>The problem is that Go's standard library's <code>errors</code> package does not make it easy to distinguish these cases. Here's an example. Let's say I have a simple HTTP handler that validates the incoming request and returns an error if the validation fails and does some work if the validation succeeds.</p><pre class=chroma><span class=kd>func</span> <span class=nf>MyHandler</span><span class=p>(</span><span class=nx>w</span> <span class=nx>http</span><span class=p>.</span><span class=nx>ResponseWriter</span><span class=p>,</span> <span class=nx>r</span> <span class=o>*</span><span class=nx>http</span><span class=p>.</span><span class=nx>Request</span><span class=p>)</span> <span class=p>{</span>
	<span class=nx>err</span> <span class=o>:=</span> <span class=nf>validateRequest</span><span class=p>(</span><span class=nx>r</span><span class=p>)</span>
	<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
		<span class=nx>w</span><span class=p>.</span><span class=nf>WriteHeader</span><span class=p>(</span><span class=nx>http</span><span class=p>.</span><span class=nx>StatusBadRequest</span><span class=p>)</span> 
		<span class=nx>w</span><span class=p>.</span><span class=nf>Write</span><span class=p>(</span><span class=nx>err</span><span class=p>.</span><span class=nf>Error</span><span class=p>())</span>
		<span class=k>return</span>
  <span class=p>}</span>
  
  <span class=c1>// Do work.
</span><span class=c1></span><span class=p>}</span>
</pre><p>The problem with the code above is that it doesn't account for the case where the <code>validateRequest()</code> function fails because of an internal error. This code would hide what could be a programming issue or an issue with a dependency and would falsely classify it as a client error with status 400. That's bad. It prevents me, as the service owner, from knowing that something's wrong; and it also prevents the end-user from accurately figuring out what actions they might need to take.</p><p>Moreover, depending on the way <code>validateRequest()</code> is written, we might end up exposing security related information to the user by simply writing <code>err.Error()</code> to the HTTP response body. What if <code>validateRequest()</code> returns an error that says "downstream auth service is down"? That would not be an appropriate message to send to the end user.</p><h2>Package <code>errors</code></h2><p>I couldn't figure out how to handle this kind of case elegantly until a collegue at work recommended I read Rob Pike and Andrew Gerrand's article <a href=https://commandcenter.blogspot.com/2017/12/error-handling-in-upspin.html>"Error handing in Upspin</a>." The key insight of the article—which maybe should have been obvious to me—is that I can define my own error type. The only thing required for something to be an error in Go is that it satisfy the error interface, which is simply:</p><pre class=chroma><span class=kd>type</span> <span class=nx>Error</span> <span class=kd>interface</span> <span class=p>{</span>
	<span class=nf>Error</span><span class=p>()</span> <span class=kt>string</span>
<span class=p>}</span>
</pre><p>When something satisfies this interface, that doesn't mean that it can't satisfy other interfaces too. In other words, the object that implements the error interface can include more functionality and information than just the <code>Error()</code> method. Here's why this is important: I can add additional information to a custom <code>Error</code> type that will allow me to distinguish between client and internal errors and which satisfies the standard library's <code>Error</code> interface.</p><p>Following Upspin's example, with a few modifications, I defined my own error type in a new errors package like so:</p><pre class=chroma><span class=c1>// Op describes an operation, usually as the package and method,
</span><span class=c1>// such as db.GetUser.
</span><span class=c1></span><span class=kd>type</span> <span class=nx>Op</span> <span class=kt>string</span>

<span class=c1>// Error implements the error interface.
</span><span class=c1></span><span class=kd>type</span> <span class=nx>Error</span> <span class=kd>struct</span> <span class=p>{</span>
        <span class=nx>err</span>      <span class=kt>error</span> <span class=c1>// The underlying error, if there is one
</span><span class=c1></span>        <span class=nx>code</span>     <span class=kt>int</span>   <span class=c1>// The HTTP status code
</span><span class=c1></span>        <span class=nx>op</span>       <span class=nx>Op</span>    <span class=c1>// The operation where the error occured
</span><span class=c1></span>        <span class=nx>messages</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>string</span> <span class=c1>// A customer-facing message
</span><span class=c1></span><span class=p>}</span>
</pre><p>The fields of <code>Error</code> are used to distinguish client from internal errors, to provide customer-facing error messages, and to provide useful traces.</p><p>I also wrote a function called <code>E()</code>, whose name I also took from Upspin, to make it easy to create these errors. Here's how it looks when it's used. You can find the implementation <a href=https://github.com/linksort/linksort/blob/main/errors/errors.go>on GitHub</a>.</p><pre class=chroma><span class=kd>func</span> <span class=nf>validateRequest</span><span class=p>(</span><span class=nx>r</span> <span class=o>*</span><span class=nx>http</span><span class=p>.</span><span class=nx>Request</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
	<span class=nx>op</span> <span class=o>:=</span> <span class=nx>errors</span><span class=p>.</span><span class=nf>Op</span><span class=p>(</span><span class=s>&#34;validateRequest&#34;</span><span class=p>)</span>
	
	<span class=nx>c</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>r</span><span class=p>.</span><span class=nf>Cookie</span><span class=p>(</span><span class=s>&#34;session-id&#34;</span><span class=p>)</span>
	<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
		<span class=k>if</span> <span class=nx>errors</span><span class=p>.</span><span class=nf>Is</span><span class=p>(</span><span class=nx>err</span><span class=p>,</span> <span class=nx>http</span><span class=p>.</span><span class=nx>ErrorNoCookie</span><span class=p>)</span> <span class=p>{</span>
			<span class=k>return</span> <span class=nx>errors</span><span class=p>.</span><span class=nf>E</span><span class=p>(</span><span class=nx>op</span><span class=p>,</span> <span class=nx>err</span><span class=p>,</span> <span class=nx>http</span><span class=p>.</span><span class=nx>StatusUnauthorized</span><span class=p>,</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>string</span><span class=p>{</span>
				<span class=s>&#34;message&#34;</span><span class=p>:</span> <span class=s>&#34;Required session cookie was not found.&#34;</span><span class=p>,</span>
			<span class=p>})</span>
		<span class=p>}</span>
		
		<span class=k>return</span> <span class=nx>errors</span><span class=p>.</span><span class=nf>E</span><span class=p>(</span><span class=nx>op</span><span class=p>,</span> <span class=nx>err</span><span class=p>,</span> <span class=nx>http</span><span class=p>.</span><span class=nx>StatusInternalServerError</span><span class=p>,</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>string</span><span class=p>{</span>
			<span class=s>&#34;message&#34;</span><span class=p>:</span> <span class=s>&#34;An internal error occurred. Please try again.&#34;</span><span class=p>,</span>
		<span class=p>})</span>
	<span class=p>}</span>
	
	<span class=k>return</span> <span class=kc>nil</span>
<span class=p>}</span>
</pre><p>Note that we've now distinguished between client and internal errors and provided a way to surface customer-facing error messages. The client error in this example occurs when a <code>session-id</code> cookie is missing from the incoming request. The internal error occurs when, for whatever reason, <code>r.Cookie()</code> returns an unexpected error. (In the <a href="https://cs.opensource.google/go/go/+/refs/tags/go1.17:src/net/http/request.go;l=421-426">implementation of <code>r.Cookie()</code></a>, this isn't actually possible, but I think this example gets the point across if you pretend that <code>r.Cookie()</code> could return such an unexpected error. It may also be worth mentioning that this is a toy example whose only purpose is to demonstrate <code>errors.E()</code>—there may be better patterns for validating cookies.)</p><p>Note that I also populated my project's <code>errors</code> package with other functions as well, such as <code>Is()</code>, <code>As()</code>, and <code>Unwrap()</code>, so that it can completely replace the standard library's <code>errors</code> package within the scope of my project.</p><h2>Package <code>payload</code></h2><p>Now that I have an <code>Error</code> type that's rich enough for me to distinguish among different kinds of errors, I need a way of returning them to end-users nicely and of printing their contents to my application's logs for debugging purposes. That's where package <code>payload</code> comes in.</p><p>Package <code>payload</code> provides utilities for dealing with HTTP requests and responses. I call it "payload" because it's primarily concerned with reading and writing request and response payloads. Here's how I use it to handle errors.</p><pre class=chroma><span class=kd>func</span> <span class=nf>MyHandler</span><span class=p>(</span><span class=nx>w</span> <span class=nx>http</span><span class=p>.</span><span class=nx>ResponseWriter</span><span class=p>,</span> <span class=nx>r</span> <span class=o>*</span><span class=nx>http</span><span class=p>.</span><span class=nx>Request</span><span class=p>)</span> <span class=p>{</span>
	<span class=nx>err</span> <span class=p>=</span> <span class=nf>validateRequest</span><span class=p>(</span><span class=nx>req</span><span class=p>)</span>
	<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
		<span class=nx>payload</span><span class=p>.</span><span class=nf>WriteError</span><span class=p>(</span><span class=nx>w</span><span class=p>,</span> <span class=nx>r</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
		<span class=k>return</span>
	<span class=p>}</span>
	
	<span class=c1>// Do work.
</span><span class=c1></span><span class=p>}</span>
</pre><p>The intended behavior is that, no matter what error is given, <code>payload.WriteError(w, r, err)</code> will write the correct information to the response.</p><p>Here's how it works. In package <code>payload</code>, I defined an interface called <code>ClientReporter</code> that my custom <code>Error</code> type implements. (I left the implementation of this interface out of the definition above, but it should be straightforward. If it isn't, take a look at the source <a href=https://github.com/linksort/linksort/blob/a1f069924f2ca535218fee66deca7776fd9d4add/errors/errors.go#L72-L114>on GitHub</a>.)</p><pre class=chroma><span class=c1>// ClientReporter provides information about an error such that client and
</span><span class=c1>// server errors can be distinguished and handled appropriately.
</span><span class=c1></span><span class=kd>type</span> <span class=nx>ClientReporter</span> <span class=kd>interface</span> <span class=p>{</span>
        <span class=kt>error</span>
        <span class=nf>Message</span><span class=p>()</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>string</span>
        <span class=nf>StatusCode</span><span class=p>()</span> <span class=kt>int</span>
<span class=p>}</span>
</pre><p>In <code>payload.WriteError(w, r, err)</code>, I check whether the given <code>err</code> implements <code>ClientReporter</code>. If it does, then I use that information to write the response to the user. If it doesn't then, I write a 500-level error to the response because that clearly means I didn't handle something right in my programming.</p><pre class=chroma><span class=kd>func</span> <span class=nf>WriteError</span><span class=p>(</span><span class=nx>w</span> <span class=nx>http</span><span class=p>.</span><span class=nx>ResponseWriter</span><span class=p>,</span> <span class=nx>r</span> <span class=o>*</span><span class=nx>http</span><span class=p>.</span><span class=nx>Request</span><span class=p>,</span> <span class=nx>e</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
	<span class=k>if</span> <span class=nx>cr</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>e</span><span class=p>.(</span><span class=nx>ClientReporter</span><span class=p>);</span> <span class=nx>ok</span> <span class=p>{</span>
		<span class=nx>status</span> <span class=o>:=</span> <span class=nx>cr</span><span class=p>.</span><span class=nf>Status</span><span class=p>()</span>
		<span class=k>if</span> <span class=nx>status</span> <span class=o>&gt;=</span> <span class=nx>http</span><span class=p>.</span><span class=nx>StatusInternalServerError</span> <span class=p>{</span>
			<span class=nf>handleInternalServerError</span><span class=p>(</span><span class=nx>w</span><span class=p>,</span> <span class=nx>r</span><span class=p>,</span> <span class=nx>e</span><span class=p>)</span>
			<span class=k>return</span>
		<span class=p>}</span>

		<span class=c1>// Write is another function provided by package payload that handles
</span><span class=c1></span>		<span class=c1>// writing JSON to http.ResponseWriter.
</span><span class=c1></span>		<span class=nf>Write</span><span class=p>(</span><span class=nx>w</span><span class=p>,</span> <span class=nx>r</span><span class=p>,</span> <span class=nx>cr</span><span class=p>.</span><span class=nf>Message</span><span class=p>(),</span> <span class=nx>status</span><span class=p>)</span>
		
		<span class=k>return</span>
	<span class=p>}</span>

	<span class=nf>handleInternalServerError</span><span class=p>(</span><span class=nx>w</span><span class=p>,</span> <span class=nx>r</span><span class=p>,</span> <span class=nx>e</span><span class=p>)</span>
<span class=p>}</span>

<span class=kd>var</span> <span class=nx>encodedErrResp</span> <span class=p>[]</span><span class=kt>byte</span> <span class=p>=</span> <span class=nx>json</span><span class=p>.</span><span class=nf>RawMessage</span><span class=p>(</span><span class=s>`{&#34;message&#34;:&#34;Something has gone wrong&#34;}`</span><span class=p>)</span>

<span class=kd>func</span> <span class=nf>handleInternalServerError</span><span class=p>(</span><span class=nx>w</span> <span class=nx>http</span><span class=p>.</span><span class=nx>ResponseWriter</span><span class=p>,</span> <span class=nx>r</span> <span class=o>*</span><span class=nx>http</span><span class=p>.</span><span class=nx>Request</span><span class=p>,</span> <span class=nx>e</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
	<span class=nx>log</span><span class=p>.</span><span class=nf>Print</span><span class=p>(</span><span class=nx>e</span><span class=p>.</span><span class=nf>Error</span><span class=p>())</span> <span class=c1>// Log errors for debugging
</span><span class=c1></span>	<span class=nx>w</span><span class=p>.</span><span class=nf>Header</span><span class=p>().</span><span class=nf>Add</span><span class=p>(</span><span class=s>&#34;Content-Type&#34;</span><span class=p>,</span> <span class=s>&#34;application/json&#34;</span><span class=p>)</span>
	<span class=nx>w</span><span class=p>.</span><span class=nf>WriteHeader</span><span class=p>(</span><span class=nx>http</span><span class=p>.</span><span class=nx>StatusInternalServerError</span><span class=p>)</span>
	
	<span class=k>if</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>w</span><span class=p>.</span><span class=nf>Write</span><span class=p>(</span><span class=nx>encodedErrResp</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
		<span class=c1>// panic, etc.
</span><span class=c1></span>	<span class=p>}</span>
<span class=p>}</span>
</pre><p>With the combination of my custom package <code>errors</code> and package <code>payload</code>, I have a streamlined way of handing errors throughout my application. I can distinguish between client and internal errors based on their HTTP statuses, which are assigned to the errors when they are created with <code>errors.E()</code>. I can also provide customer-facing error messages, that are sure not to accidentally expose any security relevant information, by means of the <code>map[string]string</code> that can also be provided to <code>errors.E()</code>. At the same time, I can log useful traces by printing underlying error messages to my application's logs, as I do in <code>handleInternalServerError()</code> above, which will make my life easier when I have to debug issues.</p></div><aside class=aside-post-container><div class="aside-post left"><a href=/articles/2022-05-15-my-search-for-america.html><p class=aside-post-arrow>&#8592; Newer</p><p class=aside-post-title>My Search for America</p></a></div><div class="aside-post right"><a href=/articles/2021-04-01-orenstien-refactoring.html><p class=aside-post-arrow>Older &#8594;</p><p class=aside-post-title>Notes on Ben Orenstein's "Refactoring from Good to Great"</p></a></div></aside></article></main><footer><section class=subscribe><form action=https://buttondown.email/api/emails/embed-subscribe/AlexanderRichey method=post target=popupwindow onsubmit="window.open('https://buttondown.email/AlexanderRichey','popupwindow')" class=embeddable-buttondown-form><h3>Subscribe to my newsletter</h3><p class=subscribe-desc>Subscribe to get my <span class=nowrap>latest articles by email.</span></p><input type=email name=email id=bd-email placeholder=jeff@amazon.com>
<input type=submit class=subscribe-submit value=Subscribe><p><span class=subscribe-buttondown><a href=https://buttondown.email target=_blank>Powered by Buttondown.</a></span></p></form></section><section class=footer-mouse><span>© 2024. All rights reserved. <span class=nowrap><a rel=alternate type=application/rss+xml href=/rss.xml>RSS</a>. <a href=/>Posts.</a> <a href=/about.html>About.</a></span></span></section><section class=footer-social><a href=https://twitter.com/AlexanderRichey target=_blank><svg class="footer-icon twitter" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" fill="#000" height="800" width="800" id="Layer_1" viewBox="0 0 310 310"><title>Follow me on Twitter</title><g id="XMLID_826_"><path id="XMLID_827_" d="M302.973 57.388c-4.87 2.16-9.877 3.983-14.993 5.463 6.057-6.85 10.675-14.91 13.494-23.73.632-1.977-.023-4.141-1.648-5.434-1.623-1.294-3.878-1.449-5.665-.39-10.865 6.444-22.587 11.075-34.878 13.783-12.381-12.098-29.197-18.983-46.581-18.983-36.695.0-66.549 29.853-66.549 66.547.0 2.89.183 5.764.545 8.598C101.163 99.244 58.83 76.863 29.76 41.204c-1.036-1.271-2.632-1.956-4.266-1.825-1.635.128-3.104 1.05-3.93 2.467-5.896 10.117-9.013 21.688-9.013 33.461.0 16.035 5.725 31.249 15.838 43.137-3.075-1.065-6.059-2.396-8.907-3.977-1.529-.851-3.395-.838-4.914.033-1.52.871-2.473 2.473-2.513 4.224-.007.295-.007.59-.007.889.0 23.935 12.882 45.484 32.577 57.229-1.692-.169-3.383-.414-5.063-.735-1.732-.331-3.513.276-4.681 1.597-1.17 1.32-1.557 3.16-1.018 4.84 7.29 22.76 26.059 39.501 48.749 44.605-18.819 11.787-40.34 17.961-62.932 17.961-4.714.0-9.455-.277-14.095-.826-2.305-.274-4.509 1.087-5.294 3.279-.785 2.193.047 4.638 2.008 5.895 29.023 18.609 62.582 28.445 97.047 28.445 67.754.0 110.139-31.95 133.764-58.753 29.46-33.421 46.356-77.658 46.356-121.367.0-1.826-.028-3.67-.084-5.508 11.623-8.757 21.63-19.355 29.773-31.536 1.237-1.85 1.103-4.295-.33-5.998C307.394 57.037 305.009 56.486 302.973 57.388z"/></g></svg></a><a href=https://quil.la/IHQNK target=_blank><svg class="footer-icon email" width="800" height="800" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><title>Send me an email</title><path d="M16 12c0 2.2091-1.7909 4-4 4-2.20914.0-4-1.7909-4-4 0-2.20914 1.79086-4 4-4 2.2091.0 4 1.79086 4 4zm0 0v1.5c0 1.3807 1.1193 2.5 2.5 2.5v0c1.3807.0 2.5-1.1193 2.5-2.5V12c0-4.97056-4.0294-9-9-9-4.97056.0-9 4.02944-9 9 0 4.9706 4.02944 9 9 9h4" stroke="#000" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg></a></section></footer></body></html>
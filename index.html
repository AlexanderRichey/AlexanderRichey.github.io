
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Alex Richey</title>
    <link rel="stylesheet" href="/assets/styles.css">
    <link rel="icon" href="/favicon.ico">
    <link rel="alternate" type="application/rss+xml" href="/rss.xml" />
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-73275866-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>
  <body>
    <header class="top-header">
    <div class="top-header-title">
      <h1>
        <a href="/">
          Alex Richey
        </a>
      </h1>
      <small>Software Engineer @ AWS</small>
    </div>
    <nav class="top-header-nav">
      <a class="top-header-nav-item" href="/">Posts</a>
      <a class="top-header-nav-item" href="/pages/about.html">About</a>
      <a class="top-header-nav-item" href="http://dev.alexrichey.com">Portfolio</a>
    </nav>
</header>
    <div class="container">
    
  
    
<article>
  <header class="article-header">
    <h1 class="article-title">
      <a href="/articles/bringing-meural-s-frontend-to-the-bleeding-edge.html">
        Bringing Meural's Frontend to the Bleeding Edge
      </a>
    </h1>
    <span class="article-date">10 July 2018</span>
  </header>
  <main>
    <div class="message">
My article on <a href="https://my.meural.com">my.meural</a>'s redesign originally published on Meural's <a href="https://medium.com/meural-product-development/bringing-our-frontend-to-the-bleeding-edge-dc81b89f8d14">Product Blog</a>.
</div>

<p>When we decided to redesign our flagship web app at Meural, we took the opportunity to rethink our approach to React and other frontend infrastructure. We ultimately decided to migrate from our own home-cooked server side rendering solution to Next.js, to change our approach to data handling with Redux, and to adopt styled-components. These decisions enabled us to develop and deploy our new frontend in just two months. In this article, I’ll talk about the upshot of these choices and about how things have worked out in production.</p>
<h2>Next.js</h2>
<p>Next.js is a framework for React apps that handles both server and client-side code. It offers a number of features, including server side rendering and automatic code-splitting in production; and hot module replacement in development. I know <a href="https://medium.com/meural-product-development/setting-up-server-side-rendering-with-react-redux-and-django-4d6f4d2fd705">from experience</a> that implementing these features from scratch is far from trivial. Therefore, the notion of starting a new project with Next.js at the foundation was attractive.</p>
<p>In addition to these flagship features, there are also positive externalities. Since Next.js is open source and has an active community behind it, common problems are faced at the community-level and standard, well-tested solutions emerge. These solutions can be found in the <a href="https://github.com/zeit/next.js/tree/canary/examples">Next.js repo</a> in a folder called <code>/examples</code>. Inside are skeleton projects with commonly desired integrations such as with Redux, styled-components, and others. Having these examples available significantly reduces mental overhead in implementing such integrations in one’s own project. This accelerates development as a result.</p>
<p>The price one pays for these features is to surrender control of routing and considerable portions of application architecture and configuration. Next.js jettisons the de facto routing standard of React-Router and requires your React application to be divided into what it calls pages. A page is a top-level React component that is associated with a URL. The notion of a page is also what enables automatic code-splitting — bundles are split at each page and preloaded on the client with <code>&lt;link rel="preload"&gt;</code>.</p>
<p>We decided that the features of Next.js, coupled with its positive externalities, outweigh the loss of control of our application architecture. Moreover, we found that adopting Next.js’ architecture simplified our application. By distinguishing between pages — those are, top-level components — and ordinary components, the directory structure of our frontend codebase became more easily comprehensible.</p>
<h2>Redux</h2>
<p>One of the challenges we faced in adopting Next.js is how to persist data across pages. Since Next.js’ architecture is based on pages, and since pages themselves are React components, which are unmounted on navigation events, their state is lost with every page navigation. We solved this problem by persisting state across page navigation events in a Redux store. What’s more, we broke away from standard Redux use patterns by using it only for persistent data.</p>
<p>Roughly speaking, use patterns of Redux can be placed on a continuum where, at one extreme, every bit of application state is stored in Redux and every mutation of state is achieved through a Redux action. At the other extreme, state is managed entirely at the component level and there is no store of global state.</p>
<p>In our previous frontend, we tended toward the former use pattern. This pattern offered some advantages — all data was fetched consistently through Redux actions with <a href="https://github.com/reduxjs/redux-thunk">Redux-Thunk</a>; and every connected component could gain visibility to any other area of the application. But we decided to abandon this approach for two main reasons. First, the excessive boilerplate that Redux requires makes extending functionality more work than it needs to be. Second, we often found ourselves dispatching actions that essentially mimic ordinary component lifecycle methods. For example, suppose that on <code>componentDidMount</code>, I fetch some data and save it in the Redux store. Then, in order to prevent the user from seeing stale data when this component loads again, I dispatch an action that clears this area of the Redux store on <code>componentWillUnmount</code>. It seems much simpler to store this data in the component state, where it will be naturally destroyed when the component unmounts and naturally fetched on <code>componentDidMount</code>, than to store it in the Redux store where it needs to be manually destroyed.</p>
<p>These considerations led us to the strategy of using Redux only for data that is truly global. As a result, we now have an extremely thin Redux store that stores only user, device, and configuration data. All other data is fetched and managed at the component level. We’ve found that this approach both makes our React components easer to comprehend and dramatically reduces boilerplate.</p>
<h2>Styled-Components</h2>
<p>The final change to our frontend stack was to adopt styled-components. In some ways, styled-components represent the terminus of a new paradigm in web development. In the old paradigm, the best-practice was to keep markup, JavaScript, and styling separate, on the grounds that these were separate concerns that should be isolated from each other. React changed this by bringing markup into JavaScript which made programmatically rendering markup less cumbersome and more easy to reason about. Styled-Components takes the philosophy that React developed and extends it to styles. It brings styling into JavaScript as well, where it can also receive the benefits of programmatic handling. The result of these developments is that concerns are grouped by component rather than by language.</p>
<p>Prior to using styled-components, our strategy was to include a sass file for every component and to bundle everything together with Webpack’s sass and css-loaders. This strategy was successful, but it often made styling components overly cumbersome. There were also the typical issues of globals and specificity in css.</p>
<p>Adopting styled-components solved these problems for us and, more significantly, it has made predicting and reasoning about the visual behavior of each component easier. We now keep all of the code related to one component in a single <code>.jsx</code> file that contains markup, JavaScript, and styling. This makes each component much easier to comprehend and, from a logistical point of view, easier to change because one no longer needs to open three or four files at the same time to handle just one locus of behavior. Now, I can open several components at once and think about their interrelations and the signatures that each one should have. In other words, I can reason about the application in a more abstracted and powerful way.</p>
<h2>Production</h2>
<p>The strategies that I described above enabled the web team at Meural, which, at the time, consisted of myself and one other developer, to build and deploy our new frontend in just two months. I believe that our focus on reducing mental overhead by making our codebase easier to comprehend enabled us to deliver on schedule. Nevertheless, we have noticed some issues in production.</p>
<p>The primary issues that we have seen are related to performance and stem from Next.js and styled-components. For all of their virtues, the combination of Next.js and styled-components creates large JavaScript bundles. At the time of this writing, our <code>main.js</code> bundle is just under 800kb and other split bundles range from less than 10kb to more than 100kb. This increased our page time to interactive from under 2.5 seconds to over 5 seconds, which is not acceptable.</p>
<p>With gzip, we can reduce the size of these bundles by roughly 75%, which would get our page load time back into an acceptable range. The problem is that Next.js does not serve static files in a straightforward way. Static assets are built and saved to the <code>/.next</code> directory, but the directory structure does not match the URLs that the client requests. These requests must be routed through the Next.js application to be resolved to the correct static asset. This prevents us from easily gzipping and serving these files independently from the Next.js application.</p>
<p>The solution that we developed is to leverage NGINX’s <a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_cache">caching capabilities</a>. For many reasons, we run our Next.js application behind an NGINX server. We decided to use the <code>proxy_cache</code> directive to cache responses at the <code>/_next/</code> location. The way this works is that the first request for any asset at <code>/_next/</code> will be forwarded to the application with <code>proxy_pass</code>, but the resulting response will be saved in NGINX’s cache. Subsequent requests will then be served out of the cache. Here are the relevant parts of the configuration.</p>
<pre><code>http {
    ...

    # Cache setup

    proxy_cache_path /data/nginx/cache keys_zone=one:20m; 
    proxy_cache_valid 200 60m;


    # Gzip settings

    gzip_static on;
    gzip on;
    gzip_comp_level 5;
    gzip_types application/javascript ...;
    gzip_min_length 1000;
    gzip_proxied expired no-cache no-store;

    server {
        listen 80;

        ...

        location /_next/ {
            proxy_pass http://application:8000;
            gzip_proxied any;
            proxy_cache one;
            break;
        }

        ...

    }
}
</code></pre>

<h2>Conclusion</h2>
<p>We have been running our new frontend stack in production for a little over two months and, so far, have had an easy time updating and extending our application. All of the decisions we made regarding Next.js, Redux, and styled-components seem to have paid off and it has been easy to live with the few inflexible areas of Next.js. After we deployed our new NGINX configuration, page load performance was restored to our target range and our application, at least in my opinion, has a wonderful, speedy, and modern feel.</p>
  </main>
</article>

  
    
<article>
  <header class="article-header">
    <h1 class="article-title">
      <a href="/articles/setting-up-server-side-rendering-with-react-redux-and-django.html">
        Setting Up Server Side Rendering with React, Redux, and Django
      </a>
    </h1>
    <span class="article-date">29 December 2017</span>
  </header>
  <main>
    <div class="message">
My article on server side rendering originally published on Meural's <a href="https://medium.com/meural-product-development/setting-up-server-side-rendering-with-react-redux-and-django-4d6f4d2fd705">Product Blog</a>.
</div>

<p>At Meural, we decided to implement server side rendering in order to increase our SEO exposure and to make social media sharing more effective. In this post, I’ll talk about how server side rendering works and the implementation that I developed.</p>
<h2>Background</h2>
<p>In traditional web applications, web pages are rendered on the client side. The browser receives a blob of JavaScript from the server, processes it, and paints the UI that the user sees. In server rendered applications, on the other hand, the first render of a web page is done on the server. The browser receives a pre-rendered page, which it can display without running any JavaScript. This enables better SEO exposure, since many web crawlers cannot run JavaScript, and faster perceived page load times.</p>
<p>There are also some downsides to server side rendering. These include slower server response time and, in lower bandwidth environments, slower time to interactive. For apps that run behind login screens, whose content is private, these downsides might make server side rendering less than worthwhile. For our use case, however, the benefits well outweigh the costs. Most of our app’s pages are public facing, so exposure to web crawlers is essential.</p>
<h2>Preliminary Considerations</h2>
<p>Implementing server side rendering is not a trivial task. In response to this fact, a number of libraries have emerged to make implementation a bit easier. These include Next.js, Razzle, numerous boilerplates, and others.</p>
<p>These libraries and frameworks can be a good choice for rapidly prototyping a feature or when starting a new app, but I would not recommend them for use in production or for extant apps. The reason for this is that using them requires surrendering a large portion of your codebase to them, which makes debugging and optimization more difficult, if not impossible, and makes you ignorant of how your app is really working. What’s more, integrating such a framework into an extant application is often more trouble than it’s worth.</p>
<p>Therefore, I developed a custom implementation of server side rendering at Meural. I hope that our stack is similar enough to that of other companies so that other developers might find this article useful. Our frontend uses React, React Router 3, and Redux, while our backend is a monolithic Django application.</p>
<h2>The High-Level View</h2>
<p>At a high level, setting up server side rendering consists in setting up the following chain of events.</p>
<p><img alt="SSR Schema" src="/assets/ssr.jpg" /></p>
<p>Since our primary application server is a Django application, which cannot understand JavaScript, we need a JavaScript runtime to render our React frontend. For this, we’ll use a Node server. When a request hits our primary Django server, we’ll query our database to get the info we need. Next we’ll send that info in an HTTP <code>POST</code> request to our Node server, which will return our markup, plus the final state of our Redux store. Finally, we’ll embed this information into the HTML response of our Django app and send it to the client.</p>
<h2>Node-Django Interaction</h2>
<p>Let’s begin by setting up the Node server. I decided to use Express.js because it is battle-tested and very easy to use. Note that we are reading our <code>NODE_HOST</code> and <code>NODE_PORT</code> variables from our runtime environment.</p>
<script src="https://gist.github.com/AlexanderRichey/96cdba8e8171d0a6bfa239b5a42db3f9.js"></script>

<p>I recommend writing a simple <code>render</code> and <code>buildInitialState</code> functions for testing purposes that simply return some valid output of any kind. I also recommend testing this server with cURL before moving on to anything else.</p>
<p>Now let’s wire up the Django app and test it’s interaction with the Node server.</p>
<script src="https://gist.github.com/AlexanderRichey/109eb5d4730be1f88fb894c05e00df03.js"></script>

<p>Here’s how we insert the rendered HTML payload into our Django template. Note that we use <a href="https://webpack.js.org/guides/getting-started/">Webpack</a> and <a href="https://github.com/ezhome/django-webpack-loader">django-webpack-loader</a> to handle our client-side JavaScript.</p>
<script src="https://gist.github.com/AlexanderRichey/925151a5fa26bd076fe37263007ff60d.js"></script>

<p>We can now test the interaction between Node and Django. Let’s start the Node server and the Django server, open up a browser, and go to the url that corresponds to our sandwich view. To prevent our React frontend from taking over the page on load, we’ll disable JavaScript in DevTools. If you see a page with the output that you defined in your <code>render</code> and <code>buildInitialState</code> functions, then all is well.</p>
<h2>Defining the Render Function</h2>
<p>It will be instructive to first look at the code of the <code>render</code> function and then to explain how it works.</p>
<script src="https://gist.github.com/AlexanderRichey/df4c27427936ae186b3725a8c1fee7d6.js"></script>

<p>The first thing the <code>render</code> function does is configure the Redux store. I used the same <code>configureStore</code> function that I had already defined in following the usual Redux API pattern.</p>
<p>The second thing the <code>render</code> function does is get the frontend routes of my React app, by calling a function I wrote called <code>getRoutes</code>. This function takes the Redux store as an argument and returns all of the routes to my app. It prevents code duplication because I can call it in both server and browser environments (See the <em>Handling the Client Side</em> section below to see how it is used in a browser environment).</p>
<p>The name <code>getRoutes</code>, though accurate, is somewhat incomplete. The function does not just get routes. It also gets the React components of which my app is composed, since they are embedded in the definitions of the routes themselves. Therefore, the <code>getRoutes</code> function is what links my existing React app to the render function.</p>
<p>Next, in order for the <code>render</code> function to match the desired route, I use React Router’s <code>match</code> function. This function’s first argument is an object containing all of my app’s routes as its first key — which we have from the <code>getRoutes</code> function — and the desired route as the second key. The match function’s second argument is a callback that gets evoked after matching is complete. In a successful matching, this callback’s third argument is a <code>renderProps</code> object. These <code>renderProps</code> represent the state of my app’s props at a given route. I pass this object into React-Router’s <code>&lt;RouterContext&gt;</code> component (which is a static version of its more familiar <code>&lt;Router&gt;</code> component) to render the state of our app at the matched route.</p>
<p>To give the components of my app access to the Redux store, I wrap the <code>&lt;RouterContext&gt;</code> component with the <code>&lt;Provider&gt;</code> component from the React-Redux library.</p>
<p>Next, I call <code>ReactDOMServer#renderToString</code> with this wrapped component as its argument to render the state of my application at the matched route to HTML.</p>
<p>Finally, I call <code>getState</code> on my Redux store to extract its final state in case the rendering process changed anything.</p>
<p>If the match function fails to match the desired route, the second argument of its callback is a <code>redirectLocation</code> argument. In this case, I recursively call the <code>render</code> function with this new desired route. I am confident that there will never be a chain of infinite redirects because I have defined a wildcard route to handle such cases.</p>
<h2>Calling the Render Function</h2>
<p>The render function will not work as it is currently defined. The reason for this is that the JSX used in the function itself, as well as in the rest of my app, is not understood in Node runtimes. Therefore, I use Webpack and Babel to transpile my <code>render.jsx</code> file into Node compliant code. All I had to do to make this work was to copy my existing webpack config, change the entry point to <code>render.jsx</code>, and replace the target parameter with <code>target: ‘node’</code>.</p>
<p>When transpiling, I ran into some errors. Since this version of my React app will not be running in the browser, window and document will not be defined. Therefore, I had to move all references to <code>window</code> and <code>document</code> to functions that are executed only after the DOM is accessible. This involved moving references to <code>window</code> and <code>document</code> from methods like <code>Component#constructor</code> to methods like <code>Component#componentDidMount</code>. Unlike <code>Component#constructor</code>, <code>Component#componentDidMount</code> will only be called after the component has been mounted to the DOM. I also had to abandon some third-party libraries that relied on <code>window</code> or <code>document</code> in problematic places.</p>
<h2>Handling the Client Side</h2>
<p>Now that my server responds with a fully rendered page of my app, I need to adjust my client side JS to expect this. Here’s the code I wrote.</p>
<script src="https://gist.github.com/AlexanderRichey/c6f0bf438ff2f6c8b8a4fc74e41658c5.js"></script>

<p>You might have noticed that I added an <code>async</code> attribute to my script tag in <code>base.html</code>. The <code>async</code> attribute makes the tag non-render-blocking, which means that the browser won’t wait for the entire script to download before rendering. This produces a considerable speed increase, especially with large JavaScript bundles. However, it also means that it is possible for the script to be executed at any time during the load process, which means that the standard procedure of waiting for <code>DOMContentLoaded</code> before rendering with ReactDOM might not always work, since <code>DOMContentLoaded</code> might have already fired, in which case, the React app would never get executed and the page would never become interactive. Therefore, I check the <code>document.readyState</code> when the bundle is initially executed. If the <code>readyState</code> is <code>complete</code> or <code>interactive</code>, I initialize my React app right away. Otherwise, I add listener for <code>DOMContentLoaded</code> and use my initialize function as the callback.</p>
<p>In my <code>initializeApp</code> function, I get the current state of the Redux store from the window and pass it into <code>configureStore</code> to setup Redux. Next, I match the current route, just as I did on the server side, using the same <code>getRoutes</code> and <code>match</code> functions which I discussed above. Instead of calling <code>ReactDOM#render</code>, which is the usual pattern in client rendered apps, I call <code>ReactDOM#hydrate</code>, which sets up React’s virtual DOM and installs listeners to make the page interactive.</p>
<h2>Conclusion</h2>
<p>Since deploying this project, we have seen much better SEO at Meural. Now a Google search for the terms <code>meural</code> and some artist’s name will yield a result of that artist’s page or one of her playlists, if that artist is in our collection. Prior to this deployment, this was not possible, since we had exposed only one webpage, which contained our single-page React app.</p>
  </main>
</article>

  
    
<article>
  <header class="article-header">
    <h1 class="article-title">
      <a href="/articles/from-philosophy-to-computer-science.html">
        From Philosophy to Computer Science
      </a>
    </h1>
    <span class="article-date">21 May 2016</span>
  </header>
  <main>
    <p><img alt="image" src="/assets/philosophy.jpg" />
When I say that I’m a software developer with a background in academic philosophy, many people react with surprise, as if I had jumped between completely divergent fields. Philosophy and computer science are in fact closely related and it is easy to transition from one to the other. In this article I would like to highlight a few reasons why this is so, with the hopes of dispelling the common misperception that they are opposites and of giving some background for students of philosophy who are interested in transitioning to computer science.</p>
<h2>Logical Similarities</h2>
<p>The basis of both philosophy and computer science is logic. In philosophy, it’s often used to evaluate arguments, whereas in computer science, it is the means by which the processor is given instructions. Having a good grasp of logic’s core concepts is essential to do well in either.</p>
<p>Consider this example to see what I mean. Suppose I say,</p>
<blockquote>
<p>If Trump or Hillary wins, then all is lost.</p>
</blockquote>
<p>This statement can be represented in philosophical notation as follows:</p>
<pre><code>(1) (A ∨ B) → C
</code></pre>

<p>where <code>A</code> is "Trump wins", <code>B</code> is "Hillary wins", <code>C</code> is "All is lost," and  <code>∨</code> and <code>→</code> are shorthand for "or" and "If … then …," respectively.</p>
<p>Now let’s write a simple program that captures the content of our claim. Let’s make our computer print "All is lost," if either Hillary or Trump win, and print "Not all is lost," if neither of them wins.</p>
<pre><code class="ruby">if trump_wins || hillary_wins
    print &quot;All is lost.&quot;
else
    print &quot;Not all is lost.&quot;
end
</code></pre>

<p>Cool. If we run this program after the election, it will print "All is lost," or "Not all is lost," depending on the result. Notice that, as far as the logic is concerned, we’ve used the exact same concepts that we used in expressing (1). The only difference is <em>syntax</em>. Here, the <code>→</code> is represented as a multi-line command and  <code>∨</code> is represented as <code>||</code>. The other addition that we’ve made is to add an imperative, namely, <code>print</code>. This is one of the main differences between pure logic and programming: Computers do things in the physical world; pure logic does not.</p>
<p>The advantage of a background in philosophy is that you are already able to translate colloquial statements into logical formulae, just as programmers do. As a student of philosophy, moreover, this kind of knowledge allows you to craft and criticize arguments. As a computer programmer, the same knowledge enables you to see several ways of building the same program; and the ability to see the far reaching, logical entailments of your claims often makes it easier to spot bugs.</p>
<h2>Analytical Similarities</h2>
<p>The way that one evaluates a philosophical position is surprisingly similar to the way a computer processor evaluates code. Both involve analytically determining what follows from what.</p>
<p>Consider the position of utilitarianism. According to this view,</p>
<blockquote>
<p>What is good is what maximizes happiness. The virtuous choice is the one that maximizes happiness.</p>
</blockquote>
<p>In order to evaluate this position, we need to consider its implications and ask if they are sound. If there is an unsound consequence, then the following logic will undermine the position. Schematically, where <code>¬</code> is 'not,' <code>A</code> is "What is good is what maximizes happiness," and <code>B</code> is some unsound consequence, we have:</p>
<pre><code>Assume:            A → B
Assume:            A
By Modus Ponens:   B
Assume:           ¬B
By Modus Tollens: ¬A ∎
</code></pre>

<p>This argument shows that, if there is some unsound consequence <code>B</code>, then <code>A</code> cannot be true.</p>
<p>In computer programming, the style of thinking involved is remarkably similar. Suppose you are writing a computer program that plays chess and you need to write a function that checks the board to see if there is a checkmate. You might start out with something like this:</p>
<pre><code class="ruby">def checkmate?
  if current_player.king.is_capturable?
    return true
  else
    return false
  end
end
</code></pre>

<p>This function checks to see if the current player's king can be captured. If it is, it returns <code>true</code>; otherwise, it returns <code>false</code>.</p>
<p>In order to evaluate this code, we perform a <em>mental stack trace</em>, that is, we imagine, as best we can, how the computer will process the code that we have just written. If our code is successful, all checkmated boards will be identified; otherwise, they won't be. Similarly, in the philosophical case, we evaluate our position by imagining all possible entailments. If our position is successful, we'll agree with all of the entailments; otherwise, we won't.</p>
<p>As it turns out, both of these cases are deficient. The problem with utilitarianism (at least in its current crude form) is that it ends up implying that slavery is not wrong, on the grounds that the intense suffering of the few may result in the highest levels of happiness for the many. This is unacceptable, so the argument above obtains. Analogously, the checkmate function will misidentify checked boards as being checkmated. The fact that the current player's king can be captured just means that she must move her king out of check, not that its capture is inevitable.</p>
<p>The point, however, is that both computer programming and philosophy involve analytically determining the consequences of one's statements; and both necessitate a certain creativity in subsequently modifying one's statements accordingly.</p>
<h2>Historical Development</h2>
<p>Besides these concrete similarities, academic philosophy played a fascinating role in the historical development of computing.</p>
<p>The conceptual work that made the advent of modern computing possible took place in the early seventeen hundreds, when the philosopher and mathematician G.W.Leibniz developed an algebraic logic. In this logic, ones and zeros represent true or false states. The reason this is significant is that Leibniz’s ones and zeros would later be rendered mechanically as on or off switches in the first primitive computers. Although it took several hundred more years and the work of countless other philosophers, mathematicians, and engineers to develop our modern notion of computing, its conceptual foundation can be traced back to Leibniz’s philosophical logic.</p>
<p>The influence of philosophy on computer science did not stop at Leibniz, however. In the early nineteen hundreds, the philosophers Bertrand Russell and Alfred North Whitehead wrote <em>Principia Mathematica</em>, a nearly 2,000 page book written largely in formal logic that aimed to couch all of mathematics in terms of logic. Although the primary aim of this book was later demonstrated to be impossible by Gödel, the <em>Principia</em> also set out a theory of types that was later put to use by computer scientists. According to Constable’s brief history, Russell and Whitehead’s theory of types</p>
<blockquote>
<p>…provided a basis for both a precise semantics and elegant programming logics. It was in this context that computer scientists and logicians created the type theories that are deeply connected to <em>Principia Mathematica</em> and serve now as comprehensive logical accounts of computing, computational mathematics, and programming logics (<a href="https://www.srcf.ucam.org/principia/files/rc.pdf">Constable</a> 3).</p>
</blockquote>
<p>Today the influence of philosophy on computer science continues, especially in the ares of artificial intelligence, the representation of information, language, and other things.</p>
  </main>
</article>

  
  <div class="pagination">
  
    <span class="pagination-item older">
      <a href="/page2/">Older</a>
    </span>
  

  
    <span class="pagination-item newer">Newer</span>
  
</div>

    </div>
    <footer>
  <small>© 2019. All rights reserved. <a rel="alternate" type="application/rss+xml" href="/rss.xml">RSS</a>.</small>
</footer>
  </body>
</html>